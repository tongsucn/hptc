#pragma once
#ifndef HPTT_TENSOR_TCC_
#define HPTT_TENSOR_TCC_

/*
 * Implementation for class TensorSize
 */
template <>
class TensorSize<0> {
  TensorSize() = delete;
};

template <>
class TensorSize<1> {
  TensorSize() = delete;
};


template <TensorUInt ORDER>
TensorSize<ORDER>::TensorSize() {
  std::fill(this->size_, this->size_ + ORDER, 0);
}


template <TensorUInt ORDER>
TensorSize<ORDER>::TensorSize(const std::array<TensorIdx, ORDER> &sizes) {
  std::copy(sizes.begin(), sizes.end(), size_);
}


template <TensorUInt ORDER>
TensorSize<ORDER>::TensorSize(const std::vector<TensorIdx> &sizes) {
  std::copy(sizes.begin(), sizes.end(), size_);
}


template <TensorUInt ORDER>
TensorSize<ORDER>::TensorSize(std::initializer_list<TensorIdx> sizes) {
  std::copy(sizes.begin(), sizes.end(), size_);
}


template <TensorUInt ORDER>
bool TensorSize<ORDER>::operator==(const TensorSize &size_obj) const {
  if (not std::equal(this->size_, this->size_ + ORDER, size_obj.size_))
    return false;
  return true;
}


template <TensorUInt ORDER>
TensorIdx &TensorSize<ORDER>::operator[](TensorUInt order_idx) {
  return this->size_[order_idx];
}


template <TensorUInt ORDER>
const TensorIdx &TensorSize<ORDER>::operator[](
    TensorUInt order_idx) const {
  return this->size_[order_idx];
}


/*
 * Implementation for class TensorWrapper
 */
template <typename FloatType,
          TensorUInt ORDER>
TensorWrapper<FloatType, ORDER>::TensorWrapper()
    : size_(),
      outer_size_(),
      raw_data_(nullptr) {
  this->init_strides_();
}


template <typename FloatType,
          TensorUInt ORDER>
TensorWrapper<FloatType, ORDER>::TensorWrapper(
    const TensorSize<ORDER> &size_obj, const FloatType *raw_data)
    : size_(size_obj),
      outer_size_(size_obj),
      raw_data_(const_cast<FloatType *>(raw_data)) {
  this->init_strides_();
}


template <typename FloatType,
          TensorUInt ORDER>
TensorWrapper<FloatType, ORDER>::TensorWrapper(
    const TensorSize<ORDER> &size_obj, const TensorSize<ORDER> &outer_size_obj,
    const FloatType *raw_data)
    : size_(size_obj),
      outer_size_(outer_size_obj),
      raw_data_(const_cast<FloatType *>(raw_data)) {
  this->init_strides_();
}


template <typename FloatType,
          TensorUInt ORDER>
TensorWrapper<FloatType, ORDER>::TensorWrapper(
    const TensorWrapper<FloatType, ORDER> &wrapper)
    : size_(wrapper.get_size()),
      outer_size_(wrapper.get_outer_size()),
      raw_data_(const_cast<FloatType *>(wrapper.get_data())) {
  this->init_strides_();
}


template <typename FloatType,
          TensorUInt ORDER>
FloatType &TensorWrapper<FloatType, ORDER>::operator[](
    const TensorIdx * RESTRICT indices) {
  TensorIdx abs_offset = 0;
  for (TensorUInt order_idx = 0; order_idx < ORDER; ++order_idx)
    abs_offset += indices[order_idx] * this->strides_[order_idx];
  return this->raw_data_[abs_offset];
}


template <typename FloatType,
          TensorUInt ORDER>
const FloatType &TensorWrapper<FloatType, ORDER>::operator[](
    const TensorIdx * RESTRICT indices) const {
  TensorIdx abs_offset = 0;
  for (TensorUInt order_idx = 0; order_idx < ORDER; ++order_idx)
    abs_offset += indices[order_idx] * this->strides_[order_idx];
  return this->raw_data_[abs_offset];
}


template <typename FloatType,
          TensorUInt ORDER>
const TensorSize<ORDER> &
TensorWrapper<FloatType, ORDER>::get_size() const {
  return this->size_;
}


template <typename FloatType,
          TensorUInt ORDER>
TensorIdx TensorWrapper<FloatType, ORDER>::get_size(
    const TensorUInt order) const {
  return this->size_[order];
}


template <typename FloatType,
          TensorUInt ORDER>
const TensorSize<ORDER> &
TensorWrapper<FloatType, ORDER>::get_outer_size() const {
  return this->outer_size_;
}


template <typename FloatType,
          TensorUInt ORDER>
TensorIdx TensorWrapper<FloatType, ORDER>::get_outer_size(
    const TensorUInt order) const {
  return this->outer_size_[order];
}


template <typename FloatType,
          TensorUInt ORDER>
void TensorWrapper<FloatType, ORDER>::reset_data(const FloatType *new_data) {
  this->raw_data_ = const_cast<FloatType *>(new_data);
}


template <typename FloatType,
          TensorUInt ORDER>
FloatType *TensorWrapper<FloatType, ORDER>::get_data() {
  return this->raw_data_;
}


template <typename FloatType,
          TensorUInt ORDER>
const FloatType *TensorWrapper<FloatType, ORDER>::get_data() const {
  return this->raw_data_;
}


template <typename FloatType,
          TensorUInt ORDER>
void TensorWrapper<FloatType, ORDER>::init_strides_() {
  if (0 == ORDER)
    return;

  this->strides_[0] = 1;
  for (TensorUInt order_idx = 0; order_idx < ORDER - 1; ++order_idx)
    this->strides_[order_idx + 1]
      = this->outer_size_[order_idx] * this->strides_[order_idx];
}


/*
 * Import explicit instantiation declaration for class TensorWrapper, this file
 * should be generated by cmake script.
 */
#include <hptt/gen/tensor_gen.tcc>

#endif // HPTT_TENSOR_TCC_
